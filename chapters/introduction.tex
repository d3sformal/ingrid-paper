\section{Introduction}

The prevailing approach to define valid syntaxes for programming languages is through grammars, which are typically written in notations based on the Extended Backus-Naur Form (EBNF).
Many tools exist for automated generation of parsers from the grammar definitions --- for example, ANTLR~\cite{ref:ANTLRBOOK,ref:ANTLR} and Bison/Flex~\cite{ref:BISONFLEX}.
The source code of programs is written in a text editor, usually embedded into an IDE. Parsers are used to create an abstract syntax tree (AST) representation of the code, e.g. inside the compiler.

An alternative approach is projectional (or structural) editing~\cite{ref:VWK15} \todo{Pridat citaci: nedavno precteny clanek o srovnani projectional editors}, where a developer directly manipulates the AST representation of the source code instead of plain text.
This idea emerged as early as in 1970s, but it failed to get adopted widely, mostly due to inconvenient and unnatural way of manipulating code.
A recent revival of projectional editing has been observed in the area of language workbenches --- IDE-like tools that enable the developers to manipulate the actual language definition.
Popular IDEs (examples) include JetBrains MPS~\cite{ref:MPS,ref:MPSBOOK} and Spoofax \todo{Pridat referenci}.
In particular, JetBrains MPS (Meta Programming System) is an open-source language workbench that focuses on domain specific languages (DSL) and leverages the concept of projectional editing.
MPS provides the whole IDE infrastructure that enables developers to design custom languages, use them to write program code, and compile the code into executables.
We provide more technical details about MPS in Section~\ref{sect:MPS}.
In the rest of the paper, we will often use \todo{examples from} MPS to illustrate the key concepts of our approach and related issues.

%MPS has put extra effort into making text manipulation feel like editing real text.
%MPS models, although being persisted as XML or binary files, can be versioned using the industry standard source-control systems (Git, Subversion).
%On-line model browsers have been incorporated into some of the popular public source code repositories (BitBucket) [reference] .

Projectional editing, keeping the code in the AST form, and the absence of parsers, brings along several benefits.
\begin{itemize}
	\item The developers practically cannot enter syntactically invalid code, because a projectional editor controls the interaction between the user and the code.
		%An AST created by the editor can represent only a syntactically valid code.
	\item Programming languages can be defined in a modular way, and multiple languages can be easily combined together or one can extend another, while parsers seriously limit language modularity for traditional parsed languages.
	\item The languages may support contextual or non-parseable notations, such as tables, diagrams and positional syntax. \todo{Zminit layout.}
	\item Since the projection is detached from the physical representation of code (AST), authors of languages can define multiple notations and allow the developers to switch between different representations of the code on the screen.
\end{itemize}
All of this is useful especially for DSLs, which are frequently used by domain experts who may not be professional software developers.
The mbeddr project~\cite{ref:MBEDDR}, which extends C with numerous domain-specific constructs and data types, illustrates the abilities of language workbenches in general and of JetBrains MPS in particular.
\todo{Benefits of projectional editing: language composition (using multiple languages in a single program), diverse notations and layouts can be used within one program.}
\todo{Popsat dalsi benefits of projectional editors/IDEs (and of MPS in particular): Projectional editors never have to parse the concrete syntax, so they can support/use more complicated syntax/layout. Support for non-linear notations (mathematical expressions, graphical or tabular layout), notations that use two-dimensional layout. Projectional editors mix different notations/styles.}
\todo{Nekam pridat text: Benefits and limitations of projectional editors are thoroughly discussed in [M. Voelter, J. Siegmund, T. Berger, and B. Kolb. Towards User-Friendly Projectional Editors. SLE 2014, LNCS 8706].}

On the other hand, the usage of projectional editors introduces some new problems.
Before a language can be used inside editors\todo{/IDEs} such as MPS, it has to be defined through the \todo{corresponding/specific} infrastructure, so that the IDE can understand the language and work with it.
Specifically, an author of a language has to create:
\begin{enumerate}
	\item the abstract syntax (structure of the language), which defines the types of allowed AST nodes,
	\item the concrete syntax used for editing, i.e. projection of the AST on the screen and its interactions with the user, and
	\item text generation scripts to enable creation of plain text files used as input for compilers.
\end{enumerate}	

%Again, we provide additional technical details in Section~\ref{sect:MPS}.

\todo{IDE systems based on projectional editors are} typically used for syntactically rich DSLs, which are likely to benefit most from overcoming the limitations of parser-based languages.
Before a program written in a rich DSL can be executed, it is \todo{has to be} transformed on the AST level by a series of model-to-model transformations to an AST model that represents the desired semantics in a general-purpose language (GPL), such as C or Java.
This model is then converted to a textual representation of that language and compiled by the standard means of the target platform.
Therefore, the target GPL must also be defined by the MPS means in order to allow the DSLs to have their models transformed into a model in the GPL.

However, very few mainstream GPLs are now fully supported by MPS \todo{Zjistit jako to maji dalsi language workbenches (Spoofax, apod)}, because it requires substantial effort to manually create a full definition of a GPL in MPS.
Only Java and C have been implemented to date, which limits the authors of DSLs to only target these supported GPLs.
The overall goal of our project is to automatize the process of language definition in MPS as much as possible, exploiting the fact that a big part of this process is quite straightforward.
We believe that such an automated process would encourage and speed-up the migration of more GPLs into MPS, thus giving the authors of DSLs more options.
Other possible applications include the support for writing programs in GPLs using the projectional editor and combination of GPLs with domain-specific languages natively created in MPS.

In this paper we present \textsc{Ingrid}, a method and a tool for semi-automated construction of the definition of a programming language in MPS that uses an ANTLR grammar of the language as a description of its syntax.
We discuss the main challenges that we encountered during the development of \textsc{Ingrid} and our solution to them.
They apply to the relation between the two approaches to the definition of a programming language --- (i) one that uses grammars in an EBNF-like notation, with rules and tokens written in plain text, and the corresponding parser generators, and (ii) the structured object-oriented approach used in MPS and other language workbenches.
Specifically, the description of a language in the form of a grammar does not hold any information about the code layout, and the grammar typically contains many rules that do not directly correspond to AST nodes and programming language constructs.
We provide more details in Section~\ref{sect:LANGDEF}.

\todo{
Napsat ze input ANTLR grammar has to be tweaked before INGRID can process them.
Za tim bude "We evaluated INGRID on complex mainstream languages, such as JavaScript and C\#. Time needed for adjusting of the mainstream languages is short ... (less than one hour).
Rict nejak zkracene nasledujici text/vetu: Therefore, the resulting MPS language typically still has to be adjusted manually to improve its usability, and the human users must also define the remaining aspects not yet supported by \textsc{Ingrid}.
}

The \textsc{Ingrid} tool can help also to make the construction of DSLs more efficient.
Based on our experience, we believe that, especially for simple languages, it is less time consuming to write their grammar by hand and then create the language definition in MPS using \textsc{Ingrid}, than to create the language manually using the MPS GUI.

%\textsc{Ingrid} allows developers to leverage all the features that MPS has to offer together with general purpose languages such as C++, JavaScript or Python.

\todo{Although we define the INGRID method in the context of MPS, it can be easily adapted for/towards construction of language definitions usable in (suitable for) other IDEs and language workbenches based on projectional editing.}
\todo{Zmenit: we explain our tool using examples from MPS and ANTLR} Although we explain everything on the examples of MPS languages and ANTLR grammars, we emphasize that most of the challenges and principles behind our approach are general and they apply also to other language workbenches.
\todo{Although we present INGRID on MPS, we believe it can be easily adapted to other language workbenches.}

\todo{Zduraznit (vyzdvihnout) general research contribution (applicable to MPS and other platforms).
	Mozna rict neco jako "INGRID efektivne resi problem XY".
	We summarize/highlight our contribution:
	\begin{itemize}
		\item Metoda pro konstrukci language definitions usable/suitable for IDEs based on projectional editing, in particular for JetBrains MPS, from ANTLR grammars, ktera je pouzitelna pro (1) import of general-purpose programming languages a (2) efficient construction of DSLs. To our belief, the method can be easily adapted to other language workbenches (e.g., Spoofax).
		\item Discussion of general challenges that apply to differences between (1) the definition of a programming language that uses grammars in an EBNF-like notation and (2) the structured object-oriented approach used in projectional editors.
		\item We discuss how practical usability of generated MPS languages depends on the specific definition of ANTLR grammar and its manual adjustments that improve usability (details in Section 3.6).
	\end{itemize}
}

The rest of the paper has the following structure.
In the next section, we provide necessary information about MPS and a brief overview of related work, including projects with similar goals as \textsc{Ingrid}.
\todo{Specifically, in Section~\ref{sect:MPS} we provide all information necessary to understand the examples from MPS presented in the paper.}
Then, in Section~\ref{sect:LANGDEF}, we describe our approach to the construction of a language definition in MPS from its ANTLR grammar, discussing the major challenges together with our solution along the way.
We also discuss our experience with usage of \textsc{Ingrid} on complex mainstream languages, such as JavaScript and C\#, and highlight open problems (Section~\ref{sect:EVAL}), and then we conclude.

