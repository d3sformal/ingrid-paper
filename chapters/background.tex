\section{Background}
\label{sect:BACKGROUND}

In this section, we introduce basic features of the MPS platform, and then we briefly discuss existing projects that aim to add support for general purpose languages into MPS.

\subsection{JetBrains MPS}
\label{sect:MPS}

MPS is a language workbench --- an IDE that allows developers to create new languages and use them to write code.
The code can be transformed into a target language, typically a GPPL such as Java or C, and compiled into executables.

When using the MPS projectional editor, the developer creates programs by assembling the AST out of predefined building blocks of selected languages.
The definition of a language in MPS dictates where in the AST certain elements can be placed and how they can be nested inside other elements.

Code of any program in MPS is built from nodes, which represent instances of concepts from the languages that the program is written in.
In MPS, a \emph{concept} is a language element, i.e. a building block of a language definition.

One of the key advantages of projectional editing stems from the separation of abstract and concrete syntax.
While AST provides a complete and precise representation of the code, the way it is displayed on the screen and the way the user edits it are unconstrained.
The editor can take any visual form and shape (i.e., not just textual).
The language author can define multiple alternative visualizations and let the developer choose one that fits best the task at hand.

The definition of an MPS concept (language element) consists of several aspects, where each aspect codifies a different part of the AST nodes' behavior.
The essential aspects are the following: \emph{Structure}, \emph{Editor} and \emph{TextGen}.
Structure represents the abstract syntax (types and hierarchy of AST nodes), Editor defines the concrete syntax (i.e., how the code is visualized and edited) and TextGen specifies how AST nodes are transformed into textual representation.
If programs in the language are supposed to be transformed into another language that is available in MPS, the Generator aspect must be used to specify the model-to-model transformation rules.
Since only the Structure, Editor and TextGen aspects are relevant for the contribution of this paper, we neglect other aspects such as type constraints.

Languages are built from the concepts using techniques known from object-oriented programming --- containment, inheritance, and so on.
Therefore, the definition of a language in MPS has an object-oriented and hierarchical nature.

\paragraph{Structure.}
The fundamental aspect of any MPS language is Structure.
It specifies core attributes of a language concept such as the name, inheritance relationships, child concepts (their types and cardinalities), and references to other AST nodes.
Figure~\ref{fig:if_statement_structure} shows the most important fragments of the Structure aspect for the \code{if-then-else} statement.

Structure also restricts the type of AST nodes that can appear at a particular place in the tree.
For example, one can restrict the condition in \code{if-then-else} to be a boolean expression, and the \code{then}-block to be a list of statements.

\begin{figure}[ht]
\vspace{-2mm}
\centering
\begin{alltt}
\small
\mpsstkeyword{concept} IfStatement \mpsstkeyword{extends} Statement
        \mpsstkeyword{implements} IContainsStatementList

  \mpsstkeyword{instance can be root:} false
  \mpsstkeyword{alias:} \mpsstalias{if}

  \mpsstkeyword{children:}
  \mpsstproperty{condition}        : Expression[\mpsstcardinality{1}]
  \mpsstproperty{ifFalseStatement} : Statement[\mpsstcardinality{0..1}]
  \mpsstproperty{ifTrue}           : StatementList[\mpsstcardinality{1}]
  \mpsstproperty{elsifClauses}     : ElsifClause[\mpsstcardinality{0..n}]
\end{alltt}
\caption{Structure aspect of the \code{if-then-else} statement}
\label{fig:if_statement_structure}
\vspace{-4mm}
\end{figure}

\paragraph{Editor.}
The Editor aspect is where the language designer specifies what the projectional representation of a code fragment (an AST) looks like on the screen and how the user interacts with the code.
JetBrains have developed a cellular system that enables placing properties and children of a node (concept) into different cells.
Individual cells of the editor can be styled using a language similar to CSS.
Supported visual characteristics include color and indentation.

Figure~\ref{fig:if_editor_definition} shows an example of what the definition of the Editor aspect for the \code{if-then-else} statement might look like.
While here we indicate positions of cell borders on each line by spaces (just for illustration), MPS GUI actually uses a graphically much more appealing way of displaying the Editor aspects, which involves vertical and horizontal lines of different colors and also background colors other than white for some cells.
The symbols \verb|[-| and \verb|-]| represent layout information, which specifies mutual positioning of the contained cells (vertical, horizontal, indentation).

\begin{figure}[ht]
\vspace{-1mm}
\centering
\begin{alltt}
\small
\mpsedannotation{<default>} \mpsedkeyword{editor for concept} \mpsedtarget{IfStatement}
  \mpsedkeyword{node cell layout:}
    [-
      \mpsedkeyword{if} \textbf{(} \% conditions \% \textbf{)} [-
      \textbf{\{}
      [- \% ifTrue % -]
      \textbf{\}}
      -]
      ?[- \mpsedkeyword{else} \% ifFalseStatement \% -]
    -]
\end{alltt}
\vspace{-1mm}
\caption{Editor aspect for the \code{if-else} statement}
\label{fig:if_editor_definition}
\vspace{-2mm}
\end{figure}

\paragraph{BaseLanguage.}
Another very important feature of MPS is \emph{BaseLanguage}~\cite{ref:BASELANG}, a clone of Java implemented using the MPS constructs.
BaseLanguage is syntactically almost identical to Java, but it is edited in a projectional editor, just like all the languages in MPS.
Custom DSLs meant to be generated into Java choose BaseLanguage as their generation target.

\paragraph{TextGen.}
The TextGen aspect specifies how a given AST node will be translated into plain text representation.
It is typically needed only for the bottom-line base languages.
DSLs, on the other hand, need to define rules for model-to-model conversions (Generators), since programs in such languages are rarely converted to text directly.
The TextGen definition follows a straightforward pattern --- each node outputs its textual representation into a buffer, while calling TextGen of its children nodes.
MPS calls the corresponding method on the root AST nodes of the given program.

\begin{figure}[ht]
\vspace{-2mm}
\centering
\begin{alltt}
\small
\mpstgkeyword{text gen component for concept} \mpstgtarget{IfStatement} \{
  \mpstgparam{(context, buffer, node)->void} \{
    \mpstgaction{append} \textcolor{blue}{\textbf{\textbackslash{}n;}}
    \mpstgaction{indent buffer;}
    \mpstgaction{append} \{\mpstgliteral{if (}\} \$\{\mpstgparam{node}.\mpstgnodeprop{condition}\} \{\mpstgliteral{) \{}\};
    \mpstgkeyword{with indent} \{
      \mpstgaction{append} \$\{\mpstgparam{node}.\mpstgnodeprop{ifTrue}\};
    \}
    \mpstgaction{append} \textcolor{blue}{\textbf{\textbackslash{}n}} \{\mpstgliteral{\}}\} \$list\{\mpstgparam{node}.\mpstgnodeprop{elsifClauses}\};
    \mpstgkeyword{if} (\mpstgparam{node}.\mpstgnodeprop{ifFalseStatement}.\textbf{isNotNull}) \{
      \mpstgaction{append} \{ \mpstgliteral{else}\} \$\{\mpstgparam{node}.\mpstgnodeprop{isFalseStatement}\};
    \}
  \}
\}
\end{alltt}
\vspace{-1mm}
\caption{TextGen aspect definition for the \code{if-else} statement}
\label{fig:if_statement_textgen}
\vspace{-2mm}
\end{figure}

TextGen aspect for each AST node (concept of the language) has to be defined using the BaseLanguage.
Again, we include an example for the \code{if-else} statement (Figure~\ref{fig:if_statement_textgen}).

\subsection{Related Projects with Similar Goals}
\label{sect:RELATED}

We are aware just of a few attempts to create ports of general-purpose languages into IDE tools based on projectional editing.
All of them (described below) were conducted manually.

The BaseLanguage~\cite{ref:BASELANG} is an almost full port of Java, extended with MPS-specific features.
The C language has also been manually tailored for MPS within the mbeddr project~\cite{ref:MBEDDR}.

The following three projects --- PE4MPS, ANTLR{\_}MPS, and mps-metabnf --- aim to provide certain support for GPPLs within the MPS platform.
We describe their main features and limitations in this section.

\paragraph{PE4MPS~\cite{ref:PE4MPS}.}
This project addresses the lack of information about code layout in grammars by using so called PE grammars~\cite{ref:PE}, which is a new notation proposed by the same author.
PE stands for projectional editing.

PE grammars extend the syntax of the ANTLR v4 notation by constructs that provide information about the possible layout of AST nodes.
The PE4MPS tool creates an MPS language in a single atomic step.
Information about the code layout, extracted from the PE file, is used when generating the projectional editor for every AST node.

The main disadvantage of the PE4MPS approach is that it only shifts the tedious manual work from creating projectional editors in the MPS IDE to writing PE grammars in plain text.
Usage of a standard text editor is inferior (and much more error-prone) with respect to MPS, which has been designed for the purpose of specifying the code layout and provides lot of support to developers.

\paragraph{ANTLR{\_}MPS~\cite{ref:ANTLR2MPS}.}
This project also uses the ANTLR v4 grammar notation, but otherwise works quite differently from PE4MPS.
Its author created an MPS language that captures the syntax of ANTLR v4 notation using MPS concepts.
Given the textual grammar of some language as input, the grammar is imported automatically into MPS, taking the form of the ANTLR v4 MPS language.
The next step would be to create a new MPS language from the grammar definition in MPS, but it is not implemented yet.

However, the project has several important limitations.
The tool does not generate any parent-child relationships in the Structure aspect, and it completely neglects the Editor and TextGen aspects.

\paragraph{mps-metabnf~\cite{ref:MPSMETABNF}.}
This tool builds upon similar ideas as the ANTLR{\_}MPS project.
Every imported grammar is represented using an ANTLR v4 MPS language.
A user is then able to adjust the grammar as he wishes, specifying the code layout in the projectional editor.
In the last step, the target MPS language is derived from the adjusted grammar definition.

The main limitation of this approach is the need to perform the last step manually, because MPS currently does not provide any support for automated transformation of a grammar captured by the ANTLR v4 MPS language into the definition of the actual target MPS language.

