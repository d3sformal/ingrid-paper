\section{Evaluation}
\label{sect:EVAL}

We implemented the proposed \textsc{Ingrid} method as an MPS plugin that allows users to generate languages from ANTLR v4 grammars.
While most of the plugin is written in Java, small fragments of BaseLanguage code were needed to bind with the MPS API, which is used to programatically generate elements of the new language and their aspects.
The plugin uses the ANTLR library~\cite{ref:ANTLR} for parsing of ANTLR v4 grammar files, and several MPS libraries that implement the MPS API.
Our complete implementation is available at \url{https://github.com/premun/ingrid}.

For the purpose of evaluation, we applied \textsc{Ingrid} to several well-established and widely used languages, including JSON, JavaScript (ECMAScript 5.1~\cite{ref:ECMASCRIPT51}), and C\#.
MPS projects that contain definitions of all three languages are also released in the public repository (\url{https://github.com/premun/ingrid}).
In the rest of this section, we discuss our experience with application of \textsc{Ingrid} to these languages, and then we highlight few general observations.

However, first we must emphasize that MPS languages automatically produced by the \textsc{Ingrid} method, as defined in this paper, are not ready-to-use full-fledged MPS counterparts of the original input languages.
The structure of such a generated MPS language fully corresponds to the respective ANTLR grammar, but its other aspects (e.g., the Editor) have to be manually tweaked (or defined from scratch) by the end user.
\textsc{Ingrid} also does not support advanced features of MPS, such as type checking.

For each of the three languages (JSON, JavaScript, and C\#), we provide (1) its MPS definition in the form that incorporates all tweaks performed manually by authors of this paper and (2) the adjusted ANTLR v4 grammar used as input for \textsc{Ingrid}, both in the repository that contains also our implementation.

\paragraph{JSON.}
The least amount of manual adjusting after the import into MPS was needed in case of the JSON language~\cite{ref:JSON}, because it is the simplest language from all that we used for our experiments.
Specifically, the first author spent less than 20 minutes in order to get a language that is ready to use.

\paragraph{JavaScript.}
In the case of JavaScript, which is an example of a widely-used complex general purpose language, automated generating of the language definition in MPS from the ANTLR grammar\footnote{https://github.com/antlr/grammars-v4/blob/master/ecmascript/ECMAScript.g4} and subsequent manual adjusting was done in less than one hour.

We are aware of other projects that aim to create a manual port of JavaScript into MPS.
For example, there is ECMAScript4MPS~\cite{ref:ECMA4MPS} developed by the author of the PE4MPS project~\cite{ref:PE4MPS} that we described in Section~\ref{sect:RELATED}.

The main advantage of \textsc{Ingrid} over ECMAScript4MPS is that, despite its current limitations, \textsc{Ingrid} fully automatically produces the definition of JavaScript in MPS that needs just minor adjustments to be really useful.
\textsc{Ingrid} achieved a very good result especially in the case of language structure, concept aliases, and support for auto-completion.
The Structure aspect generated by \textsc{Ingrid} is very similar to that of the ECMAScript4MPS project, which was created manually over a large number of hours.

\paragraph{C\#.}
Another very complex programming language that we used for experiments is C\#~\cite{ref:CSHARP}.
Before we could run \textsc{Ingrid}, we had to manually adjust the ANTLR grammar of C\# in order to ensure that \textsc{Ingrid} produces at least a reasonable structure of the MPS language.
The Editor aspect was modified afterwards, but only for some of the concepts generated by \textsc{Ingrid}. 
Roughly one hour of manual effort was needed in total.
Nevertheless, additional modifications of the grammar and selected aspects of the MPS language (Editor, TextGen) are still needed to get an optimal result.
A great flexibility and complexity of the C\# language is the main reason behind all the necessary changes to the language definition in MPS and to the ANTLR grammar.
The definition is quite large, involving more than 800 concepts, and therefore building of the language takes a rather long time.

\paragraph{Other languages.}
We also tried to apply \textsc{Ingrid} on few other languages, such as Python and Ruby.
Results are mixed because ANTLR grammars of these languages are written in a style that is not fully compatible with \textsc{Ingrid}.
For example, the structure and hierarchy of rules in the Python grammar are quite different from JavaScript or JSON, and consequently the language definition created by \textsc{Ingrid} is rather badly organized.
We plan to address this limitation in the future.
However, significant modifications of the grammar would probably be necessary anyway.

\paragraph{General observations.}
The main overall benefit of the \textsc{Ingrid} method is partial automation.
Most of the languages discussed above, which we tried to create in MPS by using \textsc{Ingrid}, are quite complex regarding their structure and syntax variety.
Therefore, completely manual definition would be a very time-consuming and error-prone process.
Fully automated generation of the Structure aspect is where \textsc{Ingrid} spares the user from many hours of tedious and sometimes quite challenging work.

On the other hand, our experiments with complex languages show that, in the case of the Editor and TextGen aspects, manual adjustment (e.g., adding line breaks and indentation) is a very effective approach that takes only a short time --- in particular, much less time than we expected.
The first author spent between 20 and 60 minutes of work on each language, when adjusting the result of automated generation into a more useful and readable form.
MPS IDE provides good support for efficient tweaking of the code layout in Editor and TextGen, allowing users to reach optimal results very fast.
All of this justifies some of our decisions that we have described in Section~\ref{sect:EDITORDEF} and Section~\ref{sect:TEXTGENDEF}, proving that our approach is quite practical.
Despite that, we also tried to design some automated heuristics during our work on the \textsc{Ingrid} project, but so far all yield rather average results when compared to what human users can achieve efficiently instead.

