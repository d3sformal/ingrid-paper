\section{Evaluation}
\label{sect:EVAL}

We implemented the proposed INGRID method as an MPS plugin that allows users to generate languages from ANTLR v4 grammars.
While most of the plugin is written in Java, small fragments of BaseLanguage code were needed to call the MPS API, e.g. in order to programmatically create new language concepts and their aspects.
The plugin uses the ANTLR library~\cite{ref:ANTLR} for parsing of ANTLR v4 grammar files, and several MPS libraries that implement the MPS API.
Our complete implementation is available at \url{https://github.com/premun/ingrid}.

For the purpose of evaluation, we applied INGRID to several well-established and widely used languages, including JSON, JavaScript, and C\#.
We used the version of JavaScript that is standardized as ECMAScript 5.1~\cite{ref:ECMASCRIPT51} --- the specification was finalized in June 2011, and it is currently the most frequently adopted version.
MPS projects that contain definitions of all three languages are also released in the public repository (\url{https://github.com/premun/ingrid}).
In the rest of this section, we discuss our experience with application of INGRID to these languages, and then we highlight few general observations.

However, first we must emphasize that MPS languages automatically produced by the INGRID method, as defined in this paper, are not ready-to-use full-fledged MPS counterparts of the original input languages.
The structure of such a generated MPS language fully corresponds to the respective ANTLR grammar, but its other aspects (e.g., the Editor) would have to be manually tweaked (or defined from scratch) by the end user.
INGRID does not yet support advanced features of MPS, such as the aspect responsible for type checking and inference.
For each of the three languages (JSON, JavaScript, and C\#), we provide (1) its MPS definition exactly in the form created by INGRID and (2) the adjusted ANTLR v4 grammar used as input for INGRID, both in the repository that contains also our implementation.

\paragraph{JSON.}
The least amount of manual adjusting after the import into MPS was needed in case of the JSON language~\cite{ref:JSON}, because it is the simplest language from all that we used for our experiments.
Specifically, the first author spent less than 20 minutes in order to get a language that is ready to use.

\paragraph{JavaScript.}
In the case of JavaScript, which is an example of a widely-used complex general purpose language, automated generating of the language definition in MPS from the ANTLR grammar\footnote{https://github.com/antlr/grammars-v4/blob/master/ecmascript/ECMAScript.g4} and subsequent manual adjusting was done in less than one hour.

We are aware of other projects that aim to create a manual port of JavaScript into MPS.
For example, there is ECMAScript4MPS~\cite{ref:ECMA4MPS} developed by the author of the PE4MPS project~\cite{ref:PE4MPS} that we described in Section~\ref{sect:RELATED}.

The main advantage of INGRID over ECMAScript4MPS is that, despite its current limitations, INGRID fully automatically produces the definition of JavaScript in MPS that needs just minor adjustments to be really useful.
INGRID achieved a very good result especially in the case of language structure, concept aliases, and support for auto-completion.
The Structure aspect generated by INGRID is very similar to that of the ECMAScript4MPS project, which was created manually in a large number of hours.






% TODO continue from here



\paragraph{C\#}.
Pred generovanim MPS jazyka pro C\# bylo nutne upravit gramatiku (coz zabralo asi hodinu prace) aby INGRID vyprodukoval pomerne rozumny vysledek.
The definition of C\# in MPS is quite large and complex.
Obsahuje asi vic nez 800 konceptu (zkontrolovat).
Import of the adjusted C\# language funguje docela hezky (ale je hodne velky a dlouho se kompiluje).
Ale na skutecne dobre pouzitelny jazyk C\# uvnitr MPS by to chtelo jeste vic manualnich uprav gramatiky a take urcitych aspektu vysledneho MPS jazyka (editor, textgen, apod).

\paragraph{Other languages.}
We also experimented with import of other languages, such as Python and Ruby.
Import jazyku Python a Ruby moc nefunguje protoze gramatika je napsana stylem ktery neni vhodny pro INGRID.
INGRID cannot handle cyclic rules (which could be found in Python grammar, for example).
Cyklicka pravidla to tedy neumi, jen na ne upozorni (a rekne, ktere pravidlo je obsahuje).
Museli bychom gramatiku rucne upravit (bude to ale nase future work).

\paragraph{General observations.}
Most of the languages (that we tried to define in MPS, use/import into MPS) are quite complex when it comes to their structure and the overall syntax variety, so defining them manually would be a very tedious, error-prone and time-consuming process.
\todo{Discuss where INGRID helps the most based on the experience.}
(Our experience/experiments show that) Automated generation of the Structure aspect is (the part) where INGRID spares the user from many hours of tedious and sometimes quite challenging work.
On the other hand, we found out that manual tweaking/adjusting of the Editor and Textgen aspects (adding line breaks and indentation) is very effective, and takes only a relatively little/short time (much less than we expected).
The imported language can be, in our opinion, adjusted very fast into a more readable form.
The generated MPS language can be customized very fast into a very usable form.
In fact/total, the adjusted version of each language was created from the original import by the first author, who spent no more than between 20 to 60 minutes of working on each of them.
The first author spent only a couple of minutes of (manually) adjusting the languages after the automated import.
Our experience with all the languages confirms our hypothesis (that code layout in the Editor aspect can be adjusted very fast, from the basic default single-row layout), and justifies some of the decisions we have described in Section X (editor aspect) and Section Y (textgen), proving that our approach is quite practical.
It takes a very short time to reach optimal results (because MPS allows doing this very efficiently), as we show on the example of importing the JavaScript language and manually adjusting all editors that needed it, all that in a less than hour time.
\todo{Mozna rict:} However, during our work on this project, we also tried to design some/various automated heuristics, but all that we came up with so far give rather suboptimal/bad results especially when compared to results produced by a human user.

